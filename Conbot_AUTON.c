#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     gyro,                sensorI2CCustom9V)
#pragma config(Motor,  mtr_S2_C1_1,     left_M1,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     left_M2,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     right_M1,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     right_M2,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C3_1,     arm_rotationMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S2_C4_1,    plow_1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C4_2,    plow_2,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <HTPB-driver-0_3.c>
#include "JoystickDriver.c"

#define k_DISTANCE 1
#define k_GYRO 1.5
#define WAIT_TIME 15

#define k_P 1.35
#define k_I 0.0
#define k_D 0.55


void initializeRobot();
void goStraight(float distance);
void turn(float delTheta);
int getScriptNumber();
float meanGyroSensorValue(tSensors s, int interval, int N);

int deadband = 300;

task main() {
  initializeRobot();
  waitForStart();

/*  switch(getScriptNumber()) {
    case 0:
    goStraight(-200);
    break;

    case 1:
    break;

    case 2:
    break;

    case 3:
    break;

    default:
    break;
  }

}

void initializeRobot() {
  deadband = meanGyroSensorValue(HTPB, 5, 150);
  servo[plow_1] = 127;
  servo[plow_2] = 128;
  return;
}

void goStraight(float distance) {

  int gyroRate;
  float error = 0;
  float lastErr, integral, derivative, p, i, d, PID;
  nMotorEncoder[right_M1] = 0;
  while (nMotorEncoder[right_M1] * k_DISTANCE < distance) {
    gyroRate = HTPBReadADC(HTPB, 2, 10); // Acquire rate of heading change info
		error += (((float)gyroRate - deadband) * WAIT_TIME * k_GYRO / 1000); // Perform the integration, and scale to degrees
    derivative = (float)(error - lastErr) / ((float)WAIT_TIME / (float)1000);
    lastErr = error;
    integral += error;
    p = error * k_P;
    i = integral * k_I;
    d = derivative * k_D;
    PID = p + i + d;
    motor[left_M1] = 75 + PID;
    motor[left_M2] = 75 + PID;

    motor[right_M1] = -75 - PID;
    motor[right_M2] = -75 - PID;

  }

  motor[left_M1] = 0;
    motor[left_M2] = 0;

    motor[right_M1] = 0;
    motor[right_M2] = 0;
}

void turn(float delTheta) {

}

float meanGyroSensorValue(tSensors s, int interval, int N)
	{
	  float som=0;
	  for(int i=0;i<N;i++)
	  {
	    som+=HTPBReadADC(s, 2, 10);
	    wait1Msec(interval);
	  }
	  som=som/N;
	  return som;
	}

int getScriptNumber() {

	SensorMode[S3] = modeBoolean;
	SensorMode[S4] = modeBoolean;

	int Sensor1Pos, Sensor2Pos;

	if (SensorValue[S3]) {Sensor1Pos = 1;}
	if (!SensorValue[S3]) {Sensor1Pos = 0;}

	if (SensorValue[S4]) {Sensor2Pos = 1;}
	if (!SensorValue[S4]) {Sensor2Pos = 0;}

	return 0; // Sensor1Pos + (2 * Sensor2Pos); // Returns a number between 0 and 3 inclusive
}

// backup drive:
/*
  time1[T1] = 0;
  while (time1[T1] < 2000) {
    motor[left_M1] = 100;
    motor[left_M2] = 100;
    motor[right_M1] = -100;
    motor[right_M2] = -100;*/
  }
