#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Motor,  mtr_S1_C1_1,     left_M2,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left_M3,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right_M3,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     left_M1,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     right_M1,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     right_M2,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <JoystickDriver.c>

#define wait_time 15.0 // wait time is given in milliseconds...
// PID constants for Buddabot... GOOD as of 02/04/11

//#define k_P 1.35 // 1.35 was .55 in last GOOD config
#define k_I 0.00 //1.25
//#define k_D 0.55 //0.55 was 0.75 in last GOOD config


task main() {
  float k_D = 0;
  float k_P = 0;
  SensorMode[S4] = modeRaw;
  int requiredHeading = 0;
  int max_speed = 0;
  int p, i, d;
  int pid;
  int integral = 0;
  float error = 0;
  float angle = 0; //was int
  bool doLoop = true;
  float angle_desired = 0;
  float angle_rate_desired = 0;

  int vals[200];
  int iter = 0;
  wait10Msec(100);
  while (iter < 200) {
    vals[iter] = SensorValue[S4];
    wait10Msec(1);
    iter++;
  }
//  iter = 0;
  int sum = 0;
  int div = 0;
  for(iter = 0; iter < 4; iter++) {
   // div += iter;
    sum += vals[iter];

  }
  nxtDisplayTextLine(2, "%d %d\n", vals[0], sum);
  wait10Msec(150);
  int offset;
  offset = (int)(sum / 4);
  nxtDisplayTextLine(2, "%d %d\n", sum, offset);
  nMotorEncoder[motorA] = 0;
  nMotorEncoder[motorB] = 0;
  float lastAngle = 0;
  float d_error = 0;

  while(1 == 1) {
angle_desired += joystick.joy1_x1 * 0.9 * wait_time / 1000;
    getJoystickSettings(joystick);
    k_D = (float)nMotorEncoder[motorA]/(float)160;
    k_P = (float)nMotorEncoder[motorB]/(float)160;

    angle_rate_desired = (joystick.joy1_x1 / 1.8);

    max_speed = -joystick.joy1_y2 * 0.65;
/*
    error = SensorValue[S4] - offset - (joystick.joy1_x1); //472 when moving??
    angle += ((error * wait_time / 1000) - 0);
    integral += angle;
*/

    error += (SensorValue[S4] - offset) * wait_time / 1000;
    d_error = (float)(error - lastAngle) / (float)(wait_time/1000);
    lastAngle = error;
  /*
    p = k_P * angle;
    i = k_I * integral;
    d = k_D * error;
*/
    p = k_P * (error - angle_desired); //(joystick.joy1_x1 * 1.25)
    i = k_I * integral;
    d = k_D * d_error;


    pid = p + i + d;
//    nxtDisplayTextLine(1, "Ag: %d, RAW: %d\n", requiredHeading, error);
    nxtDisplayTextLine(1, "d coeff: %1.5f\n", k_D);
    nxtDisplayTextLine(2, "p coeff: %1.5f\n", k_P);
//  if(abs(pid + max_speed) > 16) {
    motor[left_M1] = pid + max_speed;
    motor[left_M2] = -pid - max_speed;
    motor[left_M3] = pid + max_speed;

    motor[right_M1] = pid - max_speed;
    motor[right_M2] = -pid + max_speed;
    motor[right_M3] = pid - max_speed;

/*
  else {
    motor[left_M1] = 0;
    motor[left_M2] = 0;
    motor[left_M3] = 0;

    motor[right_M1] = 0;
    motor[right_M2] = 0;
    motor[right_M3] = 0;
  }
   */


    wait1Msec(wait_time);
  }
}
