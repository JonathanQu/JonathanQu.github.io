#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     lfConv,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rfConv,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lbConv,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rbConv,        tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float k_DISTANCE = 0.25; // Adjust this to account for radius of sprockets
// Tetrix DC motor encoders change their values by 1440 for each complete rotation of 360 degrees
// i.e., 4 for every degree of rotation
const float k_P = 1.5, k_I = 0.25, k_D = 0.5; // Tweak to change the PID convergence properties
const int nSlaves = 3; // number of Slave motors to be synchronized to the Master motor

void liftCrate(float angularDistance, int motorPower) {
  // lift the crate by turning the four sprockets for angularDistance in unit of degrees
  // using motor power level motorPower in percentage, 1 <= motorPower <= 100
    int j, Temp;
    float EncoderTarget, EncoderValue;
    float error[nSlaves], lastErr[nSlaves], integral[nSlaves], derivative[nSlaves],
          p[nSlaves], i[nSlaves], d[nSlaves], PID[nSlaves];
    // Use index j = 0 for lfConv, 1 for rbConv, 2 for rfConv to access the above PID-control arrays
    // Use Left Back Conveyor motor's Encoder value as the Master to synchronize the other three to

    nMotorEncoder[lbConv] =  nMotorEncoder[lfConv] = 0;
    nMotorEncoder[rbConv] =  nMotorEncoder[rfConv] = 0;

    // Initialize values
    for (j = 0; j < nSlaves; ++j) {
        lastErr[j]  = 0;
        error[j]    = 0;
        integral[j] = 0;
    } // end for

    Temp = nMotorEncoder[lbConv];
    while (Temp * k_DISTANCE < angularDistance) {
	      EncoderTarget = Temp; // Left Back Conveyor has the Master motor

	      // For each Slave motor to be synchronized to the Master motor
        for (j = 0; j < nSlaves; ++j) {

            // Select the proper Encoder Value to use
            if (j == 0) EncoderValue = nMotorEncoder[lfConv];
            else if (j == 1) EncoderValue = nMotorEncoder[rbConv];
            else if (j == 2) EncoderValue = nMotorEncoder[rfConv];

            error[j] += EncoderTarget - EncoderValue;

            derivative[j] = error[j] - lastErr[j];
            lastErr[j]    = error[j];
            integral[j]  += error[j];

            p[j] = error[j]      * k_P;
            i[j] = integral[j]   * k_I;
            d[j] = derivative[j] * k_D;
            PID[j] = p[j] + i[j] + d[j];

            // Apply the PID-corrected motor power after clamping it to
            //     within duty cycle range of [1,100] - assuming 75 for
            //     the Master motor of the Left Back CONVeyor
            Temp = motorPower + (int) (PID + 0.5); // Round PID to nearest integer and add to base power level
            if (Temp > 100) Temp = 100;   // Clamp the proposed power level to the range of [1,100]
            else if (Temp < 1) Temp = 0;
            if (j == 0) motor[lfConv] = Temp;
            else if (j == 1) motor[rbConv] = Temp;
            else if (j == 2) motor[rfConv] = Temp;
           } // end for
    } // end while
} // end liftCrate

task main() {
    liftCrate(360.0, 75); // Turn the four sprockets through a complete revolution
                          // of 360.0 degrees using 75% motor power
    wait1Msec(1000);
}
