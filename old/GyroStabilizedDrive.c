#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  mtr_S1_C1_1,     left_M1,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left_M2,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right_M1,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     right_M2,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     arm_manipulator, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     arm_elevator,  tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    ,                     tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

 This is the basis for the guidance and navigation (GN&C) code for Stuyvesant Fission and Fusion's 2010 - 2011 competition year robots.
 As of right now, this code is capable of corrently (or being trivially adapted for) capable of attitude control (i.e. the ability to hold the
 robot's current heading while in motion). It can also perform gyro-stabilized driving in teleoperated mode.

 Features to be implemented:

 - Turning
 - Scaling the gyroscope information so that the user can specify turns in degrees and/or radian units of measure
 - Tying in the error vector of the guidance system into other system. (i.e. collision avoidance / distance detection systems can
   sense imminent hazards and modify the error state accordingly to steer the robot without further user intervention.
 - Smoothing out the teleoperated drive stabilization, and perhaps introducing more advanced integration / filtering of gyroscope data
 - Add in a steering "gain" as a define statement, and test it, to see if steering responsivity can be improved upon (to counteract
   integration "lag")
 - Translate from tank coordinates to arcade (the current standard in GN&C) code.
 - Allow a user override to suspend guided control, and engage basic joystick drive in both modes (tank and arcade)

(c) Abhimanyu Ghosh, Stuyvesant High School, New York, NY (2010 - 2011)

 */

#include <JoystickDriver.c>
#include "HTPB-driver-0_3.c"

#define wait_time 15.0 // wait time is given in milliseconds, so (1000 / wait_time) is the refresh rate for the feedback loop...

// PID constants for Buddabot... Under testing... am not using hard-coded values as of right now

#define k_P 1.35 // 1.35 was .55 in last GOOD config
#define k_I 0.00 //1.25
#define k_D 0.55 //0.55 was 0.75 in last GOOD config

float meanGyroSensorValue(tSensors s, int interval, int N);

task main() {
  int requiredHeading = 0;
  int max_speed = 0;
  int p, i, d;
  int pid;
  int integral = 0;`
  float error = 0;
  float angle = 0;
  bool doLoop = true;
  float angle_desired = 0;
  float angle_rate_desired = 0;
  float offset = meanGyroSensorValue(HTPB, 5, 300);
	float lastAngle = 0;
	float d_error = 0;

  while(1 == 1) {
	  angle_desired += joystick.joy1_x1 * 0.9 * wait_time / 1000;
	  getJoystickSettings(joystick);

	  angle_rate_desired = (joystick.joy1_x1 / 1.8);

	  max_speed = -joystick.joy1_y2 * 0.65;

	  // This feeds the joystick rate-of-turn signal directly into the gyro signal

	  /*
		error = SensorValue[S4] - offset - (joystick.joy1_x1); //472 when moving??
		angle += ((error * wait_time / 1000) - 0);
		integral += angle;

		p = k_P * angle;
		i = k_I * integral;
		d = k_D * error;
	   */

	  // This integrates the joystick's rate-of-turn and then uses that as the new desired heading. Also makes the integrated
	  // gyro angle the basis error signal, and re-differentiates it to find the derivative term. Once again, we omit the use if the integral.
	  // (If you look above, k_I is defined to be 0.)

		error += (HTPBReadADC(HTPB, 3, 10) - offset) * wait_time / 1000;
		d_error = (float)(error - lastAngle) / (float)(wait_time/1000);
		lastAngle = error;

		p = k_P * (error - angle_desired); // Or you can just set this to a scale of error - joystick_value if you want absolute steering...
		i = k_I * integral;
		d = k_D * d_error;

    pid = p + i + d;

    motor[left_M1] = pid + max_speed;
    motor[left_M2] = pid + max_speed;

    motor[right_M1] = pid - max_speed;
    motor[right_M2] = pid - max_speed;

// TODO: Work on code to prevent application of small currents to motors (due to possible hardware implications of such actions in the
// long run.
// --Abhi

    wait1Msec(wait_time); // Refresh period of the control loop...
  }
}

float meanGyroSensorValue(tSensors s, int interval, int N)
	{
	  float som=0;
	  for(int i=0;i<N;i++)
	  {
	    som+=HTPBReadADC(s, 3, 10);
	    wait1Msec(interval);
	  }
	  som=som/N;
	  return som;
	}
