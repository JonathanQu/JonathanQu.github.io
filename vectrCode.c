#pragma config(Hubs,  S2, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     gyro,                sensorLowSpeed9v)
#pragma config(Motor,  motorA,          motorA,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorB,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     fd_left_motor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     fd_right_motor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C3_1,     back_left_motor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C3_2,     back_right_motor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C4_1,     motorH,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C4_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     motorJ,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     motorK,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    fd_left,              BadType)
#pragma config(Servo,  srvo_S2_C1_2,    fd_right,             BadType)
#pragma config(Servo,  srvo_S2_C1_3,    back_left,            BadType)
#pragma config(Servo,  srvo_S2_C1_4,    back_right,           BadType)
#pragma config(Servo,  srvo_S2_C1_5,    back_cart,            BadType)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <HTPB-driver-0_3.c>
/*
 *  VectorDriveCode.c
 *
 *
 *  Created by Abhimanyu Ghosh on 2/14/11.
 *  Copyright 2011 Abhimanyu Ghosh, Stuyvesant High School FTC Robotics. All rights reserved.
 *  Credits to Xander's HiTechnic Prototyping Board driver code, available for download at:
 *  http://www.breigh.com/xander/HTPB-driver-0_3.c
 *
 */

// Some busy-work...

#include <JoystickDriver.c>

#define servo1Deadband 98
#define servo2Deadband 137
#define servo3Deadband 129
#define servo4Deadband 121

#define WAIT_TIME 15
#define k_GYRO 1.5520
#define heading_steering_factor 0.1172 // Translates to a max turn rate of +- 15 degrees/sec.. must be tested

// NOTE: Re-zeroing the gyro now requires joystick button 8 to be pressed!!

void setAngle(int servoIndex, int angle, int motorThrust);
float meanGyroSensorValue(tSensors s, int interval, int N);

int cartServoPos;
float deadband = 0;

void initializeRobot()
{
  deadband = meanGyroSensorValue(HTPB, 5, 150);
  cartServoPos = 127;
  servo[back_cart] = cartServoPos;
  return;
}

task main() {

  initializeRobot(); // Acquire gyro initialization, and do other stuff related to initializing motors/sensors
  waitForStart(); // Wait for FCS to start running code...

  float translateDir = 0;
  float angle = 0;
  while(true) {
    getJoystickSettings(joystick);

    if(joy1Btn(5)) {              // Operates the 12V Air compressor while the button remains pressed.
      motor[motorJ] = 100;        // Recommended time to build up pressure: approx. 30 - 40 seconds.
    }
    else {
      motor[motorJ] = 0;
    }

    if(joy1Btn(7)) {              // Operates the air release valve to launch the projectile from the cannon.
      motor[motorK] = 100;        // Normally is closed (prevents air from escaping)
    }
    else {
      motor[motorK] = 0;
    }

    if (joy1Btn(3)) {
        motor[motorH] = 50;
        }
    else {
      if (joy1Btn(1)) {
        motor[motorH] = -65;
        }
    else {motor[motorH] = 0;} // Front-end "smacker" arm
}

  if (joy1Btn(2)) {cartServoPos += 1;}
    if (joy1Btn(4)) {cartServoPos -= 1;}
    if (cartServoPos < 12) {cartServoPos = 12;}
    if (cartServoPos > 255) {cartServoPos = 255;}
    servo[back_cart] = cartServoPos; // Rear cart-grabber

    int gyroRate = HTPBReadADC(HTPB, 3, 10); // Acquire rate of heading change info

    angle += (((float)gyroRate - deadband) * WAIT_TIME * k_GYRO / 1000); // Perform the integration, and scale to degrees

    // Some basic vector math to determine net thrust desired by user:

    int thrust = sqrt((joystick.joy1_y1 * joystick.joy1_y1) + (joystick.joy1_x1 * joystick.joy1_x1));
    int dir = joystick.joy1_x2 / 2; // Rate of heading change when robot is in translational motion...

    if (dir < -35) {dir = -35;}
    if (dir > 35) {dir = 35;}

    if (abs(thrust) >= 10) {

      if (joystick.joy1_x1 > 0 && joystick.joy1_y1 > 0) {
      translateDir = ((float)180 / (float)PI) * atan((float)(joystick.joy1_y1) / (float)joystick.joy1_x1);
      }
      if ((joystick.joy1_x1 < 0 && joystick.joy1_y1 < 0) || (joystick.joy1_x1 < 0 && joystick.joy1_y1 > 0)) {
      translateDir = 180 + ((float)180 / (float)PI) * atan((float)(joystick.joy1_y1) / (float)joystick.joy1_x1);
      }
      if (joystick.joy1_x1 > 0 && joystick.joy1_y1 < 0) {
        translateDir = 360 + ((float)180 / (float)PI) * atan((float)(joystick.joy1_y1) / (float)joystick.joy1_x1);
    }
    }
        nxtDisplayTextLine(1, "%1.4f \n", angle); // Debug line
    if (abs(thrust) >=  10) { // User desires translational motion

    setAngle(1, (dir + (translateDir) + angle), thrust); // Field-oriented drive magic
    setAngle(2, (dir + (translateDir) + angle), -thrust);
    setAngle(3, (-dir + (translateDir) + angle), -thrust);
    setAngle(4, (-dir + (translateDir) + angle), thrust);
}

else { // User wants to make a point turn while the robot is at rest translationally
    if ((abs(thrust) < 10) && (abs(joystick.joy1_x2) > 15)) {

    setAngle(1, 45, -joystick.joy1_x2 / 1.1);
    setAngle(2, 135, -joystick.joy1_x2 / 1.1);
    setAngle(3, 135, -joystick.joy1_x2 / 1.1);
    setAngle(4, 45, -joystick.joy1_x2 / 1.1);
      }

    else { // Null the thrust and swivel parameters on all pods
    setAngle(1, 90, 0);
    setAngle(2, 90, 0);
    setAngle(3, 90, 0);
    setAngle(4, 90, 0);
    }
  }

    if(joy1Btn(8)){angle = 0;} // Re-zero the gyro, to help combat rift....

    wait1Msec(WAIT_TIME);
  }
}

void setAngle(int servoIndex, int angle, int motorThrust) { // Name is somewhat misleading... sets angles AND thrust on each steering pod...

  if (angle < 0) {
    angle = 360 + angle; }
  if (angle > 360) {
    angle -= 360; }
  int servoSet, n;

        if (angle > 4 && angle < 176) {
                servoSet = 90 - angle; // Translate the angle to pod coordinates... leave thrust alone...
        }

        if (angle > 184 && angle < 356) {

                servoSet = 270 - angle; // Steer the other way
                motorThrust *= -1; // Reverse the motor thrust direction

        }

        else {
          if (angle <= 360 && angle >= 356 || angle >= 0 && angle <= 4) {
            servoSet = 90;
          }
          if (angle >= 176 && angle <= 184) {
            servoSet = -90;
          }
        }

        if (servoIndex == 1) {
                n = (int)(servoSet * (float)-1.5 + servo1Deadband);
                if (n < 4) {n = 4;}
                servo[fd_left] = n;
                motor[fd_left_motor] = motorThrust;
        }

        if (servoIndex == 2) {
                n = (int)(servoSet * (float)-1.5 + servo2Deadband);
                if (n > 251) {n = 251;}
                if (n < 20) {n = 20;}
                servo[fd_right] = n;
                motor[fd_right_motor] = motorThrust;
        }

        if (servoIndex == 3) {
                n = (int)(servoSet * (float)-1.5 + servo3Deadband);
                if (n > 249) {n = 249;}
                if (n < 12) {n = 12;}
                servo[back_left] = n;
                motor[back_left_motor] = motorThrust;
        }

        if (servoIndex == 4) {
                n = (int)(servoSet * (float)-1.5 + servo4Deadband);
                if (n > 239) {n = 239;}
                if (n < 0) {n = 0;}
                servo[back_right] = n;
                motor[back_right_motor] = motorThrust;
        }
}

float meanGyroSensorValue(tSensors s, int interval, int N)
        {
          float som=0;
          for(int i=0;i<N;i++)
          {
            som+=HTPBReadADC(s, 3, 10);
            wait1Msec(interval);
          }
          som=som/N;
          return som;
        }
